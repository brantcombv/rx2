<?php

abstract class Rx_Model_Collection extends Rx_Model_Abstract implements Rx_Notify_Observer
{
    /**
     * Id of current item in collection
     *
     * @var int $_current
     */
    protected $_current = null;
    /**
     * true if current collection item can be missed, false if not
     *
     * @var boolean $_emptyCurrentAllowed
     */
    protected $_emptyCurrentAllowed = true;
    /**
     * Name of corresponding Rx_Model_Entity based class (named Id to use for Rx_ModelManager)
     *
     * @var string $_entityClassName
     */
    protected $_entityClassName = null;
    /**
     * Name of collection item class (it should be based on Rx_Struct_Model_Abstract)
     *
     * @var string $_itemClassName
     */
    protected $_itemClassName = null;
    /**
     * Mapping table for synchronizing collection items list by foreign entities
     * Mapping is defined as:
     * Key is either class name or named Id (for Rx_ModelManager) of model, mapping is set for
     * Value is name of database column that holds reference for this foreign entity
     *
     * @var array $_itemsSyncMap
     */
    protected $_itemsSyncMap = array();
    /**
     * true to enable sharding for getting Ids of collection items from database
     *
     * @var boolean $_shardingEnabled
     */
    protected $_shardingEnabled = false;
    /**
     * Size of sharding range to use for getting items Ids from database
     *
     * @var int $_shardingSize
     */
    protected $_shardingSize = 100;
    /**
     * Name of database table that is represented by collection object
     *
     * @var string $_dbTableName
     */
    protected $_dbTableName = null;
    /**
     * Name of database table column name that stores item Id
     * In most cases it is primary key column.
     *
     * @var string $_dbIdColumnName
     */
    protected $_dbIdColumnName = 'id';
    /**
     * true if database Id is auto-generated on inserting new row in database,
     * false if database Id is defined manually
     *
     * @var boolean $_autoGeneratedDbId
     */
    protected $_autoGeneratedDbId = true;
    /**
     * true if collection items can be accessed by public UID, false if not
     *
     * @var boolean $_havePublicUid
     */
    protected $_havePublicUid = false;
    /**
     * Name of database table column name that stores item's public UID
     *
     * @var string $_dbPublicUidColumnName
     */
    protected $_dbPublicUidColumnName = 'public_uid';
    /**
     * true if collection item activity can be determined
     * by value of database table column, false if not.
     * IMPORTANT: This property should NOT be set to true in a case if activity column
     * is just available in database table, it should be enabled ONLY in a case if
     * checking defined database table column value is ENOUGH to determine collection item activity
     *
     * @var boolean $_haveActivityColumn
     */
    protected $_haveActivityColumn = false;
    /**
     * Name of database table column name that stores item's activity flag
     *
     * @var string $_dbActivityColumnName
     */
    protected $_dbActivityColumnName = 'is_active';
    /**
     * true if collection item deleting is done by setting value to database table column,
     * false if item deletion is done by actually deleting row from database
     *
     * @var boolean $_haveDeletedColumn
     */
    protected $_haveDeletedColumn = false;
    /**
     * Name of database table column name that stores item's deletion flag
     *
     * @var string $_dbDeletedColumnName
     */
    protected $_dbDeletedColumnName = 'is_deleted';
    /**
     * Mapping between scopes that are used by collection and database table columns
     * (in a form "scope id"=>"db column name")
     * In a case if scope is used but don't directly mapped to database table column -
     * column name should be set to null and scope should be handled in _getScopeColumn()
     *
     * @var array $_scopesMap
     */
    protected $_dbScopesMap = array();
    /**
     * Local cache for pre-defined scopes objects
     *
     * @var array $_scopesCache
     */
    protected $_scopesCache = array();

    /**
     * Class constructor
     *
     * @param array|Zend_Config $config OPTIONAL Configuration options for class
     * @return void
     * @throws Rx_Model_Exception
     */
    public function __construct($config = null)
    {
        parent::__construct($config);
        // If we have class name of collection item - normalize it
        if ($this->_itemClassName) {
            $this->_itemClassName = Rx_Loader::loadPlugin($this->_itemClassName, 'Rx_Struct_Model');
            if (!is_subclass_of($this->_itemClassName, 'Rx_Struct_Model_Abstract')) {
                throw new Rx_Model_Exception('Collection item class should be instance of Rx_Struct_Model_Abstract');
            }
        }
        // Database table name should be defined
        if (!$this->_dbTableName) {
            throw new Rx_Model_Exception('Database table name is not defined for model class ' . get_class(
                    $this
                ));
        }
        // Scopes map should be array
        if (!is_array($this->_dbScopesMap)) {
            throw new Rx_Model_Exception('Database scopes map should be defined as array for model class ' . get_class(
                    $this
                ));
        }
        // Subscribe ourselves to scopes change notifications
        Rx_Notify::subscribe($this, 'rx_scope_changed');
        // Load information about current collection item from application state
        $_current = Rx_AppState::get($this);
        if ($_current !== null) {
            $this->setCurrent($_current);
        } elseif (!$this->_emptyCurrentAllowed) // We should set current item if no empty current item is allowed for collection
        {
            $this->setCurrent();
        }
    }

    /**
     * Get model configuration
     * Mean to be used by corresponding Rx_Model_Entity class
     *
     * @return array
     */
    public function getModelConfig()
    {
        static $config = null;

        if (!$config) {
            $config = new Rx_Model_Config(array(
                'item_class'        => $this->_itemClassName,
                'entity_class'      => $this->_entityClassName,
                'db_table'          => $this->_dbTableName,
                'id_column'         => $this->_dbIdColumnName,
                'auto_id'           => $this->_autoGeneratedDbId,
                'public_uid_column' => ($this->_havePublicUid) ? $this->_dbPublicUidColumnName : null,
                'active_column'     => ($this->_haveActivityColumn) ? $this->_dbActivityColumnName : null,
                'deleted_column'    => ($this->_haveDeletedColumn) ? $this->_dbDeletedColumnName : null,
            ));
        }
        // Clone model configuration before returning to avoid its indirect modifications
        return (clone($config));
    }

    /**
     * Get database Id of collection item by given public UID
     *
     * @param string $publicUid Public UID
     * @return int|null
     */
    public function getDbId($publicUid)
    {
        if (!$this->_havePublicUid) {
            trigger_error('Public UID is not available for ' . get_class($this), E_USER_WARNING);
            return (null);
        }
        try {
            $query = $this->select()
                ->from($this->_dbTableName, $this->_dbIdColumnName)
                ->where($this->quoteIdentifier($this->_dbPublicUidColumnName) . '=?', $publicUid);
            $config = $this->getConfig();
            $this->_addScopes($query, $config);
            $dbId = $this->getAdapter()->fetchOne($query);
        } catch (Exception $e) {
            Rx_ErrorsHandler::getInstance()->exceptionsHandler($e);
            return (null);
        }
        if (!$dbId) {
            $dbId = null;
        }
        return ($dbId);
    }

    /**
     * Get public UID of collection item by given database Id
     *
     * @param int $dbId Database Id
     * @return string|null
     */
    public function getPublicUid($dbId)
    {
        if (!$this->_havePublicUid) {
            trigger_error('Public UID is not available for ' . get_class($this), E_USER_WARNING);
            return (null);
        }
        try {
            $query = $this->select()
                ->from($this->_dbTableName, $this->_dbPublicUidColumnName)
                ->where($this->quoteIdentifier($this->_dbIdColumnName) . '=?', $dbId);
            $config = $this->getConfig();
            $this->_addScopes($query, $config);
            $uid = $this->getAdapter()->fetchOne($query);
        } catch (Exception $e) {
            Rx_ErrorsHandler::getInstance()->exceptionsHandler($e);
            return (null);
        }
        if (!$uid) {
            $uid = null;
        }
        return ($uid);
    }

    /**
     * Check if given collection item Id is valid
     *
     * @param int|Rx_Struct_Model_Abstract $id Either identifier or item information structure to check
     * @param boolean $getDetails              OPTIONAL true to get details about item validity, false to just get validity status
     * @param array|Zend_Config|null $config   OPTIONAL Configuration options to override default object's configuration
     * @return boolean|array                        true if collection item Id is valid, false if not
     */
    public function isValid($id, $getDetails = false, $config = null)
    {
        $details = array(
            'id'     => null,
            'exists' => false,
            'active' => false,
        );
        if (($this->_itemClassName) && ($id instanceof $this->_itemClassName)) {
            $name = $id->getMeaningField('id');
            if ($name === null) {
                trigger_error('Failed to get item Id from provided structure', E_USER_WARNING);
                return (($getDetails) ? $details : false);
            }
            $id = $id->get($name);
        }
        if ($id === null) {
            return (($getDetails) ? $details : false);
        }
        $details['id'] = $id;
        // If no specific configuration options was passed - we should only determine
        // if given item Id is available in collection
        if ($config === null) {
            $config = array(
                'only_active' => false,
            );
        }
        $config = $this->getConfig($config);
        if ($getDetails) {
            $config = $this->modifyConfig($config, 'only_active', false);
        }
        $ids = $this->_getItemsInfo(
            'rx_get_sharding',
            array(
                'sharding' => ($this->_shardingEnabled) ? (int)floor($id / $this->_shardingSize) : null,
            ),
            $config
        );
        // Small helper for developer - notify about too large set of Ids
        if ((!$this->_shardingEnabled) && (sizeof($ids) > $this->_shardingSize)) {
            trigger_error(
                'Large amount (' . sizeof($ids) . ') of items Ids is received for class "' . get_class(
                    $this
                ) . '", it is better to enable sharding',
                E_USER_NOTICE
            );
        }
        $details['exists'] = array_key_exists($id, $ids);
        if ((!$getDetails) && (!$details['exists'])) {
            return ($details['exists']);
        }
        $active = (array_key_exists($id, $ids)) ? $ids[$id] : false;
        $details['active'] = $this->_isActive($id, $active, $config);
        if ($getDetails) {
            return ($details);
        } else {
            $r = $details['exists'];
            if ($config['only_active']) {
                $r = $r && $details['active'];
            }
            return ($r);
        }
    }

    /**
     * Check if given collection item Id is active
     *
     * @param int|Rx_Struct_Model_Abstract $id Either identifier or item information structure to check
     * @param array|Zend_Config|null $config   OPTIONAL Configuration options to override default object's configuration
     * @return boolean                              true if collection item Id is active, false if not
     */
    public function isActive($id, $config = null)
    {
        $config = $this->modifyConfig($config, 'only_active', true); // Force item activity
        return ($this->isValid($id, false, $config));
    }

    /**
     * Check if given collection item Id is active
     *
     * @param int $id              Collection item Id to check
     * @param boolean|null Current collection item activity information
     * @param array $config        Object configuration options
     * @return boolean              true if collection item Id is active, false if not
     * @throws Rx_Model_Exception
     */
    protected function _isActive($id, $active, $config)
    {
        // Method in mean to be overridden in classes
        // that need to have non-standard logic to determine item activity
        if (is_bool($active)) {
            return ($active);
        }
        throw new Rx_Model_Exception(__METHOD__ . ' should be overridden to provide collection item activity information');
    }

    /**
     * Return Id of current item in collection
     *
     * @return int|null
     */
    public function getCurrent()
    {
        if (($this->_current === null) && (!$this->_emptyCurrentAllowed)) {
            return ($this->_getDefaultId());
        }
        return ($this->_current);
    }

    /**
     * Set collection item with given Id as new current item
     *
     * @param int|null $id                   OPTIONAL Item Id to set as current (null by default)
     * @param array|Zend_Config|null $config OPTIONAL Configuration options to override default object's configuration
     * @throws Rx_Model_Exception
     * @return int|null                         Current item Id
     */
    public function setCurrent($id = null, $config = null)
    {
        if (($id === null) && (!$this->_emptyCurrentAllowed)) {
            $id = $this->_getDefaultId();
            if ($id === null) {
                throw new Rx_Model_Exception('Empty current item is not allowed for collection, but _getDefaultId() returns null');
            }
        }
        if (($id !== null) && (!$this->isValid($id, false, $config))) {
            trigger_error('Attempt to set invalid current item Id: ' . $id, E_USER_WARNING);
        } elseif ($this->_current != $id) {
            $this->_current = $id;
            $this->_onCurrentChanged();
        }
        return ($this->getCurrent());
    }

    /**
     * Perform required operations when current collection item is changed
     *
     * @return void
     * @event rx_model_collection_current_changed
     */
    protected function _onCurrentChanged()
    {
        // Method is mean to be overridden in a case if some special actions
        // should be performed when current collection item is changed
        $current = $this->getCurrent();
        Rx_AppState::set($this, $current);
        Rx_Notify::notify(
            'rx_model_collection_current_changed',
            array(
                'id' => $current,
            ),
            $this
        );
    }

    /**
     * Get Id of default collection item
     * Used if collection is not allowed to have empty current item
     *
     * @return int|null
     * @throws Rx_Model_Exception
     */
    protected function _getDefaultId()
    {
        if (!$this->_emptyCurrentAllowed) {
            throw new Rx_Model_Exception(__METHOD__ . ' should be overridden to provide non-empty default collection Id');
        }
        return (null);
    }

    /**
     * Get list of items from collection
     *
     * @TODO Implement integration with Zend_Paginator
     * @TODO Create Rx_Sortable interface and implement it in this class
     *
     * @param array|null $ids                OPTIONAL List of identifiers to limit resulted set to (all items will be returned by default)
     * @param array|Zend_Config|null $config OPTIONAL Configuration options to override default object's configuration
     * @return array
     */
    public function getItems($ids = null, $config = null)
    {
        if ($ids === null) {
            $ids = true;
        }
        if (($ids !== true) && (!is_array($ids))) {
            $ids = array($ids);
        }
        $items = $this->_getItems('rx_get_items', array('ids' => $ids), $config);
        return ($items);
    }

    /**
     * Get collection item with given Id
     *
     * @param int|null $id                   OPTIONAL Item identifier to get information for or null to use current item Id
     * @param array|Zend_Config|null $config OPTIONAL Configuration options to override default object's configuration
     * @return Rx_Struct_Model_Abstract|null
     */
    public function getItem($id = null, $config = null)
    {
        if ($id === null) {
            $id = $this->getCurrent();
            if ($id === null) {
                return (null);
            }
        }
        $items = $this->getItems(array($id), $config);
        $item = (is_array($items)) ? array_shift($items) : null;
        return ($item);
    }

    /**
     * Get collection items information by given information type and parameters
     *
     * @param string $type                   Type of information request
     * @param mixed $params                  OPTIONAL Additional request parameters
     * @param array|Zend_Config|null $config OPTIONAL Configuration options to override default object's configuration
     * @return array                            Array of collection items objects (Rx_Struct_Model_Abstract)
     */
    protected function _getItems($type, $params = null, $config = null)
    {
        $items = array();
        try {
            $config = $this->getConfig($config);
            $class = get_class($this);
            if (!is_array($params)) {
                $params = ($params !== null) ? array($params) : array();
            }
            $params['rx_query_type'] = 'items';
            $cParams = $this->_getCacheParams($type, $params, $config);
            $cacheId = $this->getCacheId($class, $cParams, false);
            if (!$this->getCache()->test($cacheId)) {
                $query = $this->_getItemsFetchingQuery($type, $params, $config);
                $query = $this->_prepareItemsFetchingQuery($type, $query, $params, $config);
                $rows = $this->_runItemsFetchingQuery($type, $query, $params, $config);
                $items = $this->_createItems($rows, $config, $type);
                $this->getCache()->save($items, $cacheId, $this->getCacheTags($class));
            } else {
                $items = $this->getCache()->load($cacheId);
            }
        } catch (Exception $e) {
            Rx_ErrorsHandler::getInstance()->exceptionsHandler($e);
            return (array());
        }
        if (!is_array($items)) {
            $items = array();
        }
        // All collection items should be filtered before returning
        // because they may not be valid since time when they was stored in cache
        /* @var $item Rx_Struct_Model_Abstract */
        foreach ($items as $id => $item) {
            if (!$this->_filterItem($item, $config)) {
                unset($items[$id]);
            }
        }
        return ($items);
    }

    /**
     * Create SQL query for given type of information fetching from database
     *
     * @param string $type   Type of information request
     * @param array $columns Database columns to build query with
     * @param array $params  Additional request parameters
     * @param array $config  Configuration options
     * @return Rx_Db_Select|array       Either single SQL query of array of Rx_Db_Select objects that will be joined by UNION
     */
    protected function _getBaseFetchingQuery($type, $columns, $params, $config)
    {
        // This method is mean to be overridden to provide custom queries
        // for fetching information from database
        // In most cases it is better to override this method since base
        // of queries for fetching items and information is normally same
        $query = $this->select()->from($this->_dbTableName, $columns);
        // Add WHERE clause and scope limitations that are defined by class configuration
        $this->_addWhere($query, $config);
        $this->_addScopes($query, $config);
        return ($query);
    }

    /**
     * Create SQL query for given type of information fetching from database
     *
     * @param string $type  Type of information request
     * @param array $params Additional request parameters
     * @param array $config Configuration options
     * @return Rx_Db_Select|array       Either single SQL query of array of Rx_Db_Select objects that will be joined by UNION
     */
    protected function _getItemsFetchingQuery($type, $params, $config)
    {
        // This method is mean to be overridden to provide custom queries
        // for fetching information from database
        $columns = $this->_getItemsFetchingQueryColumns($type, $params, $config);
        $query = $this->_getBaseFetchingQuery($type, $columns, $params, $config);
        return ($query);
    }

    /**
     * Get list of columns to fetch from database with information fetching SQL query
     * for given type of information request
     *
     * @param string $type  Type of information request
     * @param array $params Additional request parameters
     * @param array $config Configuration options
     * @return array                    Array with list of columns
     */
    protected function _getItemsFetchingQueryColumns($type, $params, $config)
    {
        // This method is mean to be overridden to provide list of columns to fetch
        // from database depending on type of information request
        $columns = array();
        switch ($type) {
            case 'rx_get_items':
            default:
                $columns = array('*');
                break;
        }
        return ($columns);
    }

    /**
     * Prepare given SQL query so it will be ready to use for fetching collection items
     *
     * @param string $type              Type of information request
     * @param Rx_Db_Select|array $query Either single SQL query of array of Rx_Db_Select objects
     * @param array $params             Additional request parameters
     * @param array $config             Configuration options
     * @return Rx_Db_Select
     */
    protected function _prepareItemsFetchingQuery($type, $query, $params, $config)
    {
        if (!is_array($query)) {
            $query = array($query);
        }
        // Add conditions that depends on requested type of information
        /* @var $_query Rx_Db_Select */
        foreach ($query as $key => $_query) {
            // Get database table prefix
            $prefix = null;
            $from = $_query->getPart(Zend_Db_Select::FROM);
            foreach ($from as $k => $v) {
                if (($v['joinType'] == 'from') && ($k != $v['tableName'])) {
                    $prefix = $k;
                    break;
                }
            }
            $this->_modifyItemsFetchingQuery($type, $key, $_query, $prefix, $params, $config);
        }
        // Join query parts
        /* @var $_query Rx_Db_Select */
        $_query = array_shift($query);
        if (sizeof($query)) {
            $_query->union($query);
        }
        $query = $_query;
        return ($query);
    }

    /**
     * Apply modifications to given SQL query that will be used for fetching collection items
     *
     * @param string $type        Type of information request
     * @param int|string $key     Key from query parts array associated with current query
     * @param Rx_Db_Select $query SQL query to apply modifications for
     * @param string|null $prefix Prefix for database table in FROM clause of given SQL query
     * @param array $params       Additional request parameters
     * @param array $config       Configuration options
     * @return void
     */
    protected function _modifyItemsFetchingQuery($type, $key, $query, $prefix, $params, $config)
    {
        // This method should be overridden in a case if some modifications
        // to standard information fetching SQL query needs to be applied
        // depending on type of information request
        // In most cases this method should provide additional WHERE clauses
        switch ($type) {
            case 'rx_get_items':
                $query->whereIn(array($prefix, $this->_dbIdColumnName), $params['ids']);
                break;
        }
    }

    /**
     * Run given SQL query and create collection items from fetched information
     *
     * @param string $type        Type of information request
     * @param Rx_Db_Select $query SQL query to run
     * @param array $params       Additional request parameters
     * @param array $config       Configuration options
     * @return array                    Array of rows fetched from database
     */
    protected function _runItemsFetchingQuery($type, $query, $params, $config)
    {
        $fMode = $this->_resolveFetchingMode($this->_getItemsFetchingMode($type, $params, $config));
        $rows = $this->getAdapter()->$fMode($query, $this->_getItemsFetchingQueryBindings($type, $params, $config));
        if (!is_array($rows)) // Make sure that we return empty array in a case if no rows are fetched
        {
            $rows = array();
        } elseif ($fMode == 'fetchRow') // _createItems() expects to get array of rows but only 1 row was fetched,
        { // put it as single item of rows array
            reset($rows);
            $rows = array(current($rows) => $rows); // Associative array is expected
        }
        return ($rows);
    }

    /**
     * Get fetching mode for SQL query for collections items information fetching
     *
     * @param string $type  Type of information request
     * @param array $params Additional request parameters
     * @param array $config Configuration options
     * @return array                    Array of bindings
     */
    protected function _getItemsFetchingMode($type, $params, $config)
    {
        // IMPORTANT: Method should return either name of information fetching method
        // or type of information fetching, @see Rx_Model_Collection::_resolveFetchingMode()
        return ('assoc');
    }

    /**
     * Resolve fetching mode for SQL query
     *
     * @param string $mode Fetching mode
     * @return string
     */
    protected function _resolveFetchingMode($mode)
    {
        // IMPORTANT: Fetching single value is not supported because
        // _createItems() and _createItemsInfo() are expected to get arrays
        $modes = array('all', 'assoc', 'row', 'col', 'pairs');
        if (preg_match('/^(?:fetch)?(' . join('|', $modes) . ')$/i', $mode, $t)) {
            $mode = 'fetch' . ucfirst(strtolower($t[1]));
            return ($mode);
        } elseif (method_exists($mode, $this->getAdapter())) {
            return ($mode);
        }
        trigger_error('Unknown information fetching mode: ' . $mode, E_USER_WARNING);
        return ('fetchAssoc');
    }

    /**
     * Get bindings for SQL query for collections items information fetching
     *
     * @param string $type  Type of information request
     * @param array $params Additional request parameters
     * @param array $config Configuration options
     * @return array                    Array of bindings
     */
    protected function _getItemsFetchingQueryBindings($type, $params, $config)
    {
        return (array());
    }

    /**
     * Create collection items objects from given database information
     *
     * @param array $data   Data to create items objects from
     * @param array $config Configuration options
     * @param string $type  OPTIONAL Type of query, this information is fetched from
     * @return array                Array of collection items objects (Rx_Struct_Model_Abstract)
     */
    protected function _createItems($data, $config, $type = null)
    {
        if (!$this->_itemClassName) {
            trigger_error('Collection items creation is not allowed - item class name is not defined', E_USER_WARNING);
            return (array());
        }
        $items = array();
        // Construct collection items from fetched information
        foreach ($data as $item) {
            /* @var $item Rx_Struct_Model_Abstract */
            $item = $this->_createItem($item, $config);
            if ($item instanceof $this->_itemClassName) {
                $items[$item->getByMeaning('id')] = $item;
            }
        }
        return ($items);
    }

    /**
     * Create item structure object by provided information from database (or other data source)
     *
     * @param array $data   Data to create item object from
     * @param array $config Configuration options
     * @return Rx_Struct_Model_Abstract|null|false  Created item on success, null if item can't be created for some reason, false in a case of error
     */
    protected function _createItem($data, $config)
    {
        if (!$this->_itemClassName) {
            trigger_error('Collection items creation is not allowed - item class name is not defined', E_USER_WARNING);
            return (false);
        }
        $class = $this->_itemClassName;
        $item = new $class($data);
        return ($item);
    }

    /**
     * Create list of structures for storing list of referenced Ids
     * from given list of database Ids
     *
     * @param array $ids    List of referenced Ids from database (in a form "primary key"=>"referenced Id")
     * @param array $config Configuration options
     * @return array
     */
    protected function _createIdsList($ids, $config)
    {
        $result = array();
        if (is_array($ids)) {
            foreach ($ids as $id => $ref) {
                $result[$id] = new Rx_Struct_Model_Id(array(
                    'id'    => $ref,
                    'db_id' => $id,
                ));
            }
        }
        return ($result);
    }

    /**
     * Filter given item by configuration options
     *
     * @param Rx_Struct_Model_Abstract $item Collection item to filter
     * @param array $config                  Configuration options to use for filtering
     * @return boolean                          true if item should be stored in collection, false to skip it
     */
    protected function _filterItem($item, $config)
    {
        if (($this->_itemClassName) && (!$item instanceof $this->_itemClassName)) {
            return (false);
        }
        if (($config['only_active']) && (!$item->getByMeaning('active', true))) {
            return (false);
        }
        return (true);
    }

    /**
     * Get list of Ids of items from collection
     *
     * @param array|null $ids                OPTIONAL List of identifiers to limit resulted set to (all items Ids will be returned by default)
     * @param array|Zend_Config|null $config OPTIONAL Configuration options to override default object's configuration
     * @return array                            Array of collection items Ids (in a form "id"=>"item activity")
     */
    public function getItemsIds($ids = null, $config = null)
    {
        if ($ids === null) {
            $ids = true;
        }
        if (($ids !== true) && (!is_array($ids))) {
            $ids = array($ids);
        }
        $items = $this->_getItemsInfo('rx_get_ids', array('ids' => $ids), $config);
        return ($items);
    }

    /**
     * Get collection items information by given information type and parameters
     *
     * @param string $type                   Type of information request
     * @param mixed $params                  OPTIONAL Additional request parameters
     * @param array|Zend_Config|null $config OPTIONAL Configuration options to override default object's configuration
     * @return array                            Array of collection items information (in a form "id"=>"information")
     */
    protected function _getItemsInfo($type, $params = null, $config = null)
    {
        $info = array();
        try {
            $config = $this->getConfig($config);
            $class = get_class($this);
            if (!is_array($params)) {
                $params = ($params !== null) ? array($params) : array();
            }
            $params['rx_query_type'] = 'info';
            $cParams = $this->_getCacheParams($type, $params, $config);
            $cacheId = $this->getCacheId($class, $cParams, false);
            if (!$this->getCache()->test($cacheId)) {
                $query = $this->_getItemsInfoFetchingQuery($type, $params, $config);
                $query = $this->_prepareItemsInfoFetchingQuery($type, $query, $params, $config);
                $rows = $this->_runItemsInfoFetchingQuery($type, $query, $params, $config);
                $info = $this->_createItemsInfo($type, $rows, $config);
                $this->getCache()->save($info, $cacheId, $this->getCacheTags($class));
            } else {
                $info = $this->getCache()->load($cacheId);
            }
        } catch (Exception $e) {
            Rx_ErrorsHandler::getInstance()->exceptionsHandler($e);
            return (array());
        }
        if (!is_array($info)) {
            $info = array();
        }
        foreach ($info as $id => $_info) {
            if (!$this->_filterItemInfo($type, $id, $_info, $config)) {
                unset($info[$id]);
            }
        }
        return ($info);
    }

    /**
     * Create SQL query for given type of information fetching from database
     *
     * @param string $type  Type of information request
     * @param array $params Additional request parameters
     * @param array $config Configuration options
     * @return Rx_Db_Select|array       Either single SQL query of array of Rx_Db_Select objects that will be joined by UNION
     */
    protected function _getItemsInfoFetchingQuery($type, $params, $config)
    {
        // This method is mean to be overridden to provide custom queries
        // for fetching information from database.
        // Difference from _getItemsFetchingQuery() it that this query is mean
        // to fetch arbitrary information depending on information request type and parameters
        // IMPORTANT: SQL queries should be constructed in a way so collection items Ids
        // will be fetched as first column in recordset. It will allow to get items Ids
        // as array keys when information will be fetched from database. Remaining columns
        // should contain information that is required to build requested information set
        // @see _createItemsInfo()
        $columns = $this->_getItemsInfoFetchingQueryColumns($type, $params, $config);
        $query = $this->_getBaseFetchingQuery($type, $columns, $params, $config);
        return ($query);
    }

    /**
     * Get list of columns to fetch from database with information fetching SQL query
     * for given type of information request
     *
     * @param string $type  Type of information request
     * @param array $params Additional request parameters
     * @param array $config Configuration options
     * @return array                    Array with list of columns
     */
    protected function _getItemsInfoFetchingQueryColumns($type, $params, $config)
    {
        // This method is mean to be overridden to provide list of columns to fetch
        // from database depending on type of information request
        // IMPORTANT: Database Id column should be first in list in any case!
        $columns = array($this->_dbIdColumnName);
        switch ($type) {
            case 'rx_get_ids':
            case 'rx_get_sharding':
            default:
                if ($this->_haveActivityColumn) {
                    $columns[] = $this->_dbActivityColumnName;
                }
                break;
            case 'rx_get_sync_ids':
                break;
        }
        return ($columns);
    }

    /**
     * Prepare given SQL query so it will be ready to use for fetching collection items information
     *
     * @param string $type              Type of information request
     * @param Rx_Db_Select|array $query Either single SQL query of array of Rx_Db_Select objects
     * @param array $params             Additional request parameters
     * @param array $config             Configuration options
     * @return Rx_Db_Select
     */
    protected function _prepareItemsInfoFetchingQuery($type, $query, $params, $config)
    {
        if (!is_array($query)) {
            $query = array($query);
        }
        // Add conditions that depends on requested type of information
        /* @var $_query Rx_Db_Select */
        foreach ($query as $key => $_query) {
            // Get database table prefix
            $prefix = null;
            $from = $_query->getPart(Zend_Db_Select::FROM);
            foreach ($from as $k => $v) {
                if (($v['joinType'] == 'from') && ($k != $v['tableName'])) {
                    $prefix = $k;
                    break;
                }
            }
            $this->_modifyItemsInfoFetchingQuery($type, $key, $_query, $prefix, $params, $config);
        }
        // Join query parts
        /* @var $_query Rx_Db_Select */
        $_query = array_shift($query);
        if (sizeof($query)) {
            $_query->union($query);
        }
        $query = $_query;
        return ($query);
    }

    /**
     * Apply modifications to given SQL query that will be used for fetching collection items information
     *
     * @param string $type        Type of information request
     * @param int|string $key     Key from query parts array associated with current query
     * @param Rx_Db_Select $query SQL query to apply modifications for
     * @param string|null $prefix Prefix for database table in FROM clause of given SQL query
     * @param array $params       Additional request parameters
     * @param array $config       Configuration options
     * @return void
     */
    protected function _modifyItemsInfoFetchingQuery($type, $key, $query, $prefix, $params, $config)
    {
        // This method should be overridden in a case if some modifications
        // to standard information fetching SQL query needs to be applied
        // depending on type of information request
        // In most cases this method should provide additional WHERE clauses
        switch ($type) {
            case 'rx_get_ids':
                $query->whereIn(array($prefix, $this->_dbIdColumnName), $params['ids']);
                break;
            case 'rx_get_sharding':
                if ($this->_haveDeletedColumn) {
                    $query->where(
                        $this->quoteIdentifier(array($prefix, $this->_dbDeletedColumnName)) . '=?',
                        false
                    );
                }
                if ($this->_shardingEnabled) {
                    $query->where(
                        $this->quoteIdentifier(
                            array($prefix, $this->_dbIdColumnName)
                        ) . ' between :sharding_start and :sharding_end'
                    );
                }
                break;
            case 'rx_get_sync_ids':
                $query->where($this->quoteIdentifier(array($prefix, $params['column'])) . '=?', $params['value']);
                break;
        }
    }

    /**
     * Run given SQL query and create collection items from fetched information
     *
     * @param string $type        Type of information request
     * @param Rx_Db_Select $query SQL query to run
     * @param array $params       Additional request parameters
     * @param array $config       Configuration options
     * @return array                    Array of rows fetched from database
     */
    protected function _runItemsInfoFetchingQuery($type, $query, $params, $config)
    {
        $fMode = $this->_resolveFetchingMode($this->_getItemsInfoFetchingMode($type, $params, $config));
        $rows = $this->getAdapter()->$fMode($query, $this->_getItemsInfoFetchingQueryBindings($type, $params, $config));
        if (!is_array($rows)) {
            $rows = array();
        }
        return ($rows);
    }

    /**
     * Get fetching mode for SQL query for collections items information fetching
     *
     * @param string $type  Type of information request
     * @param array $params Additional request parameters
     * @param array $config Configuration options
     * @return array                    Array of bindings
     */
    protected function _getItemsInfoFetchingMode($type, $params, $config)
    {
        // IMPORTANT: Method should return either name of information fetching method
        // or type of information fetching, @see Rx_Model_Collection::_resolveFetchingMode()
        return ('assoc');
    }

    /**
     * Get bindings for SQL query for collections items information fetching
     *
     * @param string $type  Type of information request
     * @param array $params Additional request parameters
     * @param array $config Configuration options
     * @return array                    Array of bindings
     */
    protected function _getItemsInfoFetchingQueryBindings($type, $params, $config)
    {
        $bindings = array();
        switch ($type) {
            case 'rx_get_sharding':
                if ($this->_shardingEnabled) {
                    $sharding = (array_key_exists('sharding', $params)) ? $params['sharding'] : 0;
                    $start = $sharding * $this->_shardingSize;
                    $end = $start + $this->_shardingSize - 1;
                    $bindings = array(
                        'sharding_start' => $start,
                        'sharding_end'   => $end,
                    );
                }
                break;
        }
        return ($bindings);
    }

    /**
     * Create items information sets by given recordset
     *
     * @param string $type  Type of information request
     * @param array $rows   Information recordset
     * @param array $config Configuration options
     * @return array                    Items information set in a form "id=>information".
     */
    protected function _createItemsInfo($type, $rows, $config)
    {
        $result = array();
        if (!sizeof($rows)) {
            return ($result);
        }
        foreach ($rows as $key => $row) {
            if (is_array($row)) {
                reset($row);
                $id = current($row);
            } else {
                $id = $key;
            }
            $path = array($id);
            $skip = false;
            $info = $this->_createItemInfo($type, $id, $row, $config, $path, $skip);
            if ($skip) {
                continue;
            }
            if (!is_array($path)) {
                $path = array($path);
            }
            if (sizeof($path) == 1) {
                $path = array_shift($path);
                if (!array_key_exists($path, $result)) {
                    $result[$path] = $info;
                } else {
                    trigger_error(
                        'Indexes overlap into results set, some information is get lost (index: ' . $path . ')',
                        E_USER_WARNING
                    );
                }
            } else {
                $t = & $result;
                $n = sizeof($path);
                $tp = array();
                foreach ($path as $p) {
                    $tp[] = $p;
                    if (--$n > 0) {
                        if (!is_array($t)) {
                            trigger_error(
                                'Indexes overlap into results set, some information is get lost (indexes path: ' . join(
                                    '/',
                                    $tp
                                ) . ')',
                                E_USER_WARNING
                            );
                            break;
                        } elseif (!array_key_exists($p, $t)) {
                            $t[$p] = array();
                        }
                        $tt = & $t[$p];
                        unset($t);
                        $t = & $tt;
                        unset($tt);
                    } else {
                        $t[$p] = $info;
                    }
                }
                unset($t);
            }
        }
        return ($result);
    }

    /**
     * Create collection item information set by given values
     *
     * @param string $type  Type of information request
     * @param int $id       Collection item Id to build information for
     * @param array $values List of values fetched from database to build information from
     * @param array $config Configuration options
     * @param array $path   OPTIONAL "Path" within results set to store item information to
     * @param boolean $skip OPTIONAL true to skip storing result in results set
     * @return mixed            Information that is required for given type of information request
     */
    protected function _createItemInfo($type, $id, $values, $config, &$path, &$skip)
    {
        // This method is mean to be overridden in a case if there is
        // some special logic needs to be implemented to prepare requested information
        // based on information fetched from database.
        switch ($type) {
            case 'rx_get_ids':
            case 'rx_get_sharding':
                // We need to get item activity
                $active = true;
                array_shift($values); // Remove item Id from list of values
                foreach ($values as $v) {
                    $active = ($active && (boolean)$v);
                }
                return ($active);
                break;
            case 'rx_get_sync_ids':
                return ($id);
                break;
            default:
                return ($values);
                break;
        }
    }

    /**
     * Filter given item information set by configuration options
     *
     * @param string $type  Type of information request
     * @param int $id       Collection item Id, information belongs to
     * @param array $info   Information set
     * @param array $config Configuration options to use for filtering
     * @return boolean              true if information should be returned as part of results set, false to skip it
     */
    protected function _filterItemInfo($type, $id, $info, $config)
    {
        switch ($type) {
            default:
                if (($config['only_active']) && (is_bool($info)) && (!$info)) {
                    return (false);
                }
                break;
        }
        return (true);
    }

    /**
     * Get scope information for model queries
     *
     * @param array|Zend_Config|null $config OPTIONAL Configuration options to override default object's configuration
     * @param string $prefix                 OPTIONAL Table prefix for database column names
     * @return array                            Array of Rx_Scope_Limit objects
     * @throws Rx_Model_Exception
     */
    public function getScopes($config = null, $prefix = null)
    {
        $scopes = array();
        $config = $this->getConfig($config);
        foreach ($this->_dbScopesMap as $scope => $column) {
            $cache = true;
            if (!$column) {
                $cache = false; // Don't cache scopes that depends on external logic
                $column = $this->_getScopeColumn($scope, $config);
                if ($column === null) {
                    continue;
                }
            }
            $key = ($prefix !== null) ? $prefix : '_';
            if ((array_key_exists($scope, $this->_scopesCache)) &&
                (array_key_exists($key, $this->_scopesCache[$scope]))
            ) {
                $scopes[] = $this->_scopesCache[$scope][$key];
            } else {
                $null = null;
                if (is_array($column)) {
                    $t = array_shift($column);
                    $null = array_shift($column);
                    $column = $t;
                }
                $column = $this->quoteIdentifier(array($prefix, $column));
                $obj = new Rx_Scope_Limit($scope, null, $column, $null);
                $scopes[] = $obj;
                if ($cache) {
                    if (!array_key_exists($scope, $this->_scopesCache)) {
                        $this->_scopesCache[$scope] = array();
                    }
                    $this->_scopesCache[$scope][$key] = $obj;
                }
            }
        }
        return ($scopes);
    }

    /**
     * Get name of database table column to bind given scope to
     *
     * @param string $scope Scope name to get column name for
     * @param array $config Object configuration options
     * @return string|array|null        Database column name or null to disable using this scope
     * @throws Rx_Model_Exception
     */
    protected function _getScopeColumn($scope, $config)
    {
        // Method is mean to be overridden in a case if scopes
        // can't be defined completely through $_dbScopesMap
        throw new Rx_Model_Exception('Failed to construct SQL query scoping because incomplete scopes mapping is provided');
    }

    /**
     * Add "where" limitation information to given SQL query based on model configuration
     *
     * @param Rx_Db_Select $query SQL query to add "where" information to
     * @param array $config       Configuration options
     * @param string $prefix      OPTIONAL Table prefix for database column names
     * @return void
     * @throws Rx_Model_Exception
     */
    protected function _addWhere($query, $config, $prefix = null)
    {
        if (!$query instanceof Zend_Db_Select) {
            throw new Rx_Model_Exception('Query should be instance of Zend_Db_Select');
        }
        if (($config['only_active']) && ($this->_haveActivityColumn)) {
            $query->where($this->quoteIdentifier(array($prefix, $this->_dbActivityColumnName)) . '=?', true);
        }
        if ($this->_haveDeletedColumn) {
            $query->where($this->quoteIdentifier(array($prefix, $this->_dbDeletedColumnName)) . '=?', false);
        }
    }

    /**
     * Add scoping information to given SQL query based on model configuration
     *
     * @param Rx_Db_Select $query SQL query to add scopes information to
     * @param array $config       Configuration options
     * @param string $prefix      OPTIONAL Table prefix for database column names
     * @return void
     * @throws Rx_Model_Exception
     */
    protected function _addScopes($query, $config, $prefix = null)
    {
        if (!$query instanceof Rx_Db_Select) {
            throw new Rx_Model_Exception('Query should be instance of Rx_Db_Select');
        }
        $scopes = $this->getScopes($config, $prefix);
        if (!sizeof($scopes)) {
            $query->noScope();
            return;
        }
        foreach ($scopes as $scope) {
            $query->scope($scope);
        }
    }

    /**
     * Get list of parameters that should be taken in mind when constructing cache key
     *
     * @param string $type  Type of information request
     * @param array $params Additional request parameters
     * @param array $config Configuration options
     * @return array
     */
    protected function _getCacheParams($type, $params, $config)
    {
        $qType = (array_key_exists('rx_query_type', $params)) ? $params['rx_query_type'] : null;
        unset($params['rx_query_type']);
        $cParams = $this->_getCacheParamsPrepare($type, $params, $qType, $config);
        // Store type of information request if not yet stored
        if (!array_key_exists('type', $cParams)) {
            $cParams['type'] = $type;
        }
        // If configuration options are not yet stored - add them into list of parameters
        if (!array_key_exists('cfg', $cParams)) {
            $cParams['cfg'] = $config;
        }
        // Add scopes into list of cache parameters
        if (!array_key_exists('scope', $cParams)) {
            $scopes = $this->getScopes($config);
            if (sizeof($scopes)) {
                $cParams['scope'] = array();
                /* @var $scope Rx_Scope_Limit */
                foreach ($scopes as $scope) {
                    $cParams['scope'][$scope->getId()] = $scope->getValue();
                }
            }
        }
        // Perform additional filtering of collected cache parameters depending on type
        // of information that will be cached, it will allow to make cache more effective
        $cParams = $this->_getCacheParamsFilter($type, $cParams, $qType, $config);
        return ($cParams);
    }

    /**
     * Prepare list of parameters that should be included into cache parameters list
     * from given list of information request parameters
     *
     * @param string $type  Type of information request
     * @param array $params Additional request parameters
     * @param string $qType Query type Id (from "rx_query_type" parameter)
     * @param array $config Configuration options
     * @return array
     */
    protected function _getCacheParamsPrepare($type, $params, $qType, $config)
    {
        $cParams = array(
            'cfg' => $config,
        );
        // Process given parameters depending on given information type
        switch ($type) {
            case 'rx_get_items':
            case 'rx_get_ids':
                $cParams['ids'] = ($params['ids'] === true) ? 'all' : $params['ids'];
                break;
            default:
                $cParams = $cParams + $params;
                break;
        }
        return ($cParams);
    }

    /**
     * Filter given list of cache parameters
     *
     * @param string $type  Type of information that will be cached
     * @param array $params List of collected cache parameters
     * @param string $qType Query type Id (from "rx_query_type" parameter)
     * @param array $config Configuration options
     * @return array
     */
    protected function _getCacheParamsFilter($type, $params, $qType, $config)
    {
        // If all configuration options are filtered out - remove "cfg" entry
        if ((array_key_exists('cfg', $params)) && (is_array($params['cfg']))) {
            unset($params['cfg'][Rx_Configurable_Abstract::CONFIG_CLASS_ID_KEY]);
            unset($params['cfg']['permanent_delete']);
            if (!sizeof($params['cfg'])) {
                unset($params['cfg']);
            }
        }
        // Same for scope variables
        if ((array_key_exists('scope', $params)) && (is_array($params['scope'])) && (!sizeof($params['scope']))) {
            unset($params['scope']);
        }
        return ($params);
    }

    /**
     * Get instance of entity model class to operate with collection item with given Id
     *
     * @param int|string|Rx_Struct_Model_Abstract|null $id  OPTIONAL Either identifier or item information structure to get model for
     *                                                      or null to use current item Id
     * @param array|Zend_Config|null $config                OPTIONAL Configuration options to override default object's configuration
     * @param array|Zend_Config|null $entityConfig          OPTIONAL Configuration options for entity model object
     * @return Rx_Model_Entity|null
     * @throws Rx_Model_Exception
     */
    public function getEntity($id = null, $config = null, $entityConfig = null)
    {
        if (!$this->_itemClassName) {
            trigger_error('Entity receiving is not allowed - item class name is not defined', E_USER_WARNING);
            return (null);
        }
        if (!$this->_entityClassName) {
            trigger_error('Entity receiving is not allowed - entity class name is not defined', E_USER_WARNING);
            return (null);
        }
        $item = null;
        if ($id instanceof $this->_itemClassName) {
            $item = $id;
            $id = $item->getByMeaning('id');
        } elseif ($id === null) {
            $id = $this->getCurrent();
            if ($id === null) {
                return (null);
            }
        } elseif (!is_scalar($id)) {
            throw new Rx_Model_Exception('Collection item Id should be either item structure or identifier');
        }
        if (!$item instanceof $this->_itemClassName) {
            $item = $this->getItem($id, $config);
        }
        if (!$item instanceof $this->_itemClassName) {
            return (null);
        }
        $entity = Rx_ModelManager::get($this->_entityClassName, $item, $entityConfig);
        if (!$entity instanceof Rx_Model_Entity) {
            throw new Rx_Model_Exception('Failed to get entity class "' . $this->_entityClassName . '"');
        }
        return ($entity);
    }

    /**
     * Get list of Ids of collection items that belongs to given entity
     *
     * @param Rx_Model_Entity $entity        Entity to get list of Ids for
     * @param array|Zend_Config|null $config OPTIONAL Configuration options to override default object's configuration
     * @return array
     * @throws Rx_Model_Exception
     */
    public function getEntitySyncIds($entity, $config = null)
    {
        if (!$entity instanceof Rx_Model_Entity) {
            throw new Rx_Model_Exception('Entity for Ids synchronization must be instance of Rx_Model_Entity');
        }
        $ids = array();
        $eClass = get_class($entity);
        $column = null;
        foreach ($this->_itemsSyncMap as $name => $col) {
            if ($name != $eClass) {
                $class = Rx_ModelManager::getClass($name);
                if (($class == $eClass) ||
                    (is_subclass_of($entity, $class))
                ) {
                    $column = $col;
                }
            } else {
                $column = $col;
            }
            if ($column) {
                break;
            }
        }
        if ($column) {
            $config = $this->getConfig($config);
            $ids = $this->_getItemsInfo(
                'rx_get_sync_ids',
                array(
                    'column' => $column,
                    'value'  => $entity->getStruct()->getByMeaning($config['sync_meaning_id']),
                ),
                $config
            );
        }
        return ($ids);
    }

    /**
     * Create new item in collection by given data
     *
     * @param array|Rx_Struct_Abstract $data       Initial data for newly created item
     * @param array|Zend_Config|null $config       OPTIONAL Configuration options to override default object's configuration
     * @param array|Zend_Config|null $entityConfig OPTIONAL Configuration options for entity model object
     * @param boolean $getEntity                   OPTIONAL true to get entity object of newly added collection item, false to get database Id (default)
     * @return int|Rx_Model_Entity|false                    Id of newly created item or false in a case of error
     * @throws Rx_Model_Exception
     */
    public function addItem($data, $config = null, $entityConfig = null, $getEntity = false)
    {
        if (!$this->_itemClassName) {
            trigger_error(
                'Adding items into collection is not allowed - item class name is not defined',
                E_USER_WARNING
            );
            return (false);
        }
        if (!$this->_entityClassName) {
            trigger_error(
                'Adding items into collection is not allowed - entity class name is not defined',
                E_USER_WARNING
            );
            return (false);
        }
        if ($data instanceof $this->_itemClassName) {
            $item = $data;
        } else /* @var $item Rx_Struct_Model_Abstract */ {
            $item = new $this->_itemClassName($data);
        }
        /* @var $entity Rx_Model_Entity */
        $entity = Rx_ModelManager::get($this->_entityClassName, $item, $entityConfig);
        if (!$entity->save(array('insert' => true))) {
            return (false);
        }
        if ($getEntity) {
            return ($entity);
        }
        return ($entity->getByMeaning('db_id'));
    }

    /**
     * Delete items with given Ids from collection
     *
     * @param array $ids                     Id of collection item to delete
     * @param array|Zend_Config|null $config OPTIONAL Configuration options to override default object's configuration
     * @return boolean                          true on successful delete, false in a case of error
     */
    public function deleteItems($ids, $config = null)
    {
        if (!is_array($ids)) {
            $ids = array($ids);
        }
        if (!sizeof($ids)) {
            return (true);
        }
        try {
            $config = $this->getConfig($config);
            $scopes = $this->getScopes($config);
            if (($this->_haveDeletedColumn) && (!$config['permanent_delete'])) {
                $this->update(
                    $this->_dbTableName,
                    array($this->_dbDeletedColumnName => true),
                    $this->quoteInto($this->_dbIdColumnName . ' in (?)', $ids),
                    $scopes
                );
            } else {
                $this->delete(
                    $this->_dbTableName,
                    $this->quoteInto($this->_dbIdColumnName . ' in (?)', $ids),
                    $scopes
                );
            }
        } catch (Exception $e) {
            Rx_ErrorsHandler::getInstance()->exceptionsHandler($e);
            return (false);
        }
        return (true);
    }

    /**
     * Delete item with given Id from collection
     *
     * @param int|string|Rx_Struct_Model_Abstract $id Either identifier or item information structure to delete
     * @param array|Zend_Config|null $config          OPTIONAL Configuration options to override default object's configuration
     * @return boolean                                  true on successful delete, false in a case of error
     */
    public function deleteItem($id, $config = null)
    {
        if (($this->_itemClassName) && ($id instanceof $this->_itemClassName)) {
            $id = $id->getByMeaning('db_id');
        }
        if (!is_scalar($id)) {
            trigger_error('Item for deletion should be either item Id or item information structure', E_USER_WARNING);
            return (false);
        }
        return ($this->deleteItems(array($id), $config));
    }

    /**
     * Quotes an identifier.
     *
     * @param string|array|Zend_Db_Expr $ident The identifier.
     * @param boolean $auto                    If true, heed the AUTO_QUOTE_IDENTIFIERS config option.
     * @return string                               The quoted identifier.
     */
    public function quoteIdentifier($ident, $auto = false)
    {
        // $ident may contain empty prefix, we should remove it
        if (is_array($ident)) {
            foreach ($ident as $k => $v) {
                if (!strlen($v)) {
                    unset($ident[$k]);
                }
            }
        }
        return (parent::quoteIdentifier($ident, $auto));
    }

    /**
     * Get object's configuration or configuration option with given name
     * If argument is passed as string - value of configuration option with this name will be returned
     * If argument is some kind of configuration options set - it will be merged with current object's configuration and returned
     * If no argument is passed - current object's configuration will be returned
     *
     * @param string|array|Zend_Config|boolean|null $config OPTIONAL Option name to get or configuration options
     *                                                      to override default object's configuration.
     *                                                      Boolean values are used as shortcuts for "only_active" configuration option
     * @return mixed
     */
    public function getConfig($config = null)
    {
        if (($config === true) || ($config === false)) {
            $config = array('only_active' => $config);
        }
        return (parent::getConfig($config));
    }

    /**
     * Initialize list of configuration options
     */
    protected function _initConfig()
    {
        parent::_initConfig();
        $this->_mergeConfig(array(
            'only_active'      => true, // true to only work with active items, false to work with all available items
            'permanent_delete' => false, // true to perform permanent delete operation regardless
            // of existence of "deleted" flag in entity table
            'sync_meaning_id'  => 'db_id', // Name of the meaning to use for fetching database Id
            // from given external entity during entity Ids syncing process
        ));
    }

    /**
     * Check that given value of configuration option is valid
     *
     * @param string $name      Configuration option name
     * @param mixed $value      Option value (passed by reference)
     * @param string $operation Current operation Id
     * @return boolean
     */
    protected function _checkConfig($name, &$value, $operation)
    {
        switch ($name) {
            case 'only_active':
            case 'permanent_delete':
                $value = (boolean)$value;
                break;
            case 'sync_meaning_id':
                if (!$value) {
                    $value = 'db_id';
                }
                break;
            default:
                return (parent::_checkConfig($name, $value, $operation));
                break;
        }
        return (true);
    }

    /**
     * Handle given notification event
     *
     * @param Rx_Notify_Event $event Notification event object
     * @return void
     */
    public function handleNotify($event)
    {
        switch ($event->getType()) {
            case 'rx_scope_changed':
                // Remove changed scope from cache
                unset($this->_scopesCache[$event->get('id')]);
                break;
        }
    }

}

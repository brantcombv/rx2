<?php

/**
 * MVC URL targets parsing and generation class
 */
class Rx_Url
{
    /**
     * Constant for "__id__" parameter into structure of parsed MV target
     *
     * @var string
     */
    const STRUCT_ID = 'Rx_Url_Mvc_Target';
    /**
     * Implementation of Singleton pattern
     *
     * @var Rx_Url $_instance
     */
    protected static $_instance = null;
    /**
     * Additional configuration options
     *
     * @var Rx_Configurable_Embedded $_config
     */
    protected $_config = null;

    /**
     * Class constructor
     *
     * @return void
     */
    private function __construct()
    {
        $this->_config = new Rx_Configurable_Embedded($this, array(
            // URL generation parameters
            'complete_url'       => false,
            // true to construct complete URL
            'domain'             => null,
            // Domain name to use for constructing complete URL
            'protocol'           => 'http',
            // Protocol name to use for constructing complete URL
            'port'               => null,
            // Port number to use for constructing complete URL
            // MVC related parameters
            'default_route'      => 'default',
            // Default MVC route name, default value is taken from Zend_Controller_Router_Rewrite::addDefaultRoutes()
            'default_module'     => 'default',
            // Default MVC module name, default values are taken from Zend_Controller_Dispatcher_Abstract
            'default_controller' => 'index',
            // Default MVC controller name
            'default_action'     => 'index',
            // Default MVC action name
            // Parameters related to router matching
            'router_matching'    => false,
            // Return parsing results in format that is expected
            // to be returned by routers matching method
            // @see Zend_Controller_Router_Route#match()
            'router_reset'       => true,
            // true to reset the route defaults with those provided
            'router_encode'      => true,
            // Encode URL parts on output
            // Parameters related to MVC target construction
            'mvc_use_router'     => true,
            // true to use MVC routing subsystem for assembling URLs
            // Set to false in a case if no Zend_Controller_Front is available for application
            'mvc_use_module'     => false,
            // true to add module MVC component into MVC target generated by toMvc(), false to skip it
            'mvc_prefix'         => null,
            // Prefix to add for MVC target generated by toMvc()
            'mvc_mask'           => false,
            // true to construct MVC mask, false to create complete MVC target
            // Parameters related to URL assembling
            'base_url'           => '/',
            // Base URL to use for URLs assembling
        ), array(
            'checkConfig' => '_checkConfig',
        ));
    }

    private function __clone()
    {
    }

    /**
     * Singleton instance
     *
     * @return Rx_Url
     */
    public static function getInstance()
    {
        if (null === self::$_instance) {
            self::$_instance = new self();
        }
        return (self::$_instance);
    }

    /**
     * Get object's configuration or configuration option with given name
     * If argument is passed as string - value of configuration option with this name will be returned
     * If argument is some kind of configuration options set - it will be merged with current object's configuration and returned
     * If no argument is passed - current object's configuration will be returned
     *
     * @param string|array|Zend_Config|null $config OPTIONAL Option name to get or configuration options
     *                                              to override default object's configuration.
     * @return mixed
     */
    public static function getConfig($config = null)
    {
        return (self::getInstance()->_config->getConfig($config));
    }

    /**
     * Set configuration options for object
     *
     * @param array|string|Zend_Config $config      Configuration options to set
     * @param mixed $value                          If first parameter is passed as string then it will be treated as
     *                                              configuration option name and $value as its value
     * @return void
     */
    public static function setConfig($config, $value = null)
    {
        self::getInstance()->_config->setConfig($config, $value);
    }

    /**
     * Check that given value of configuration option is valid
     *
     * @param string $name      Configuration option name
     * @param mixed $value      Option value (passed by reference)
     * @param string $operation Current operation Id
     * @return boolean
     */
    public function _checkConfig($name, &$value, $operation)
    {
        switch ($name) {
            case 'complete_url':
            case 'router_matching':
            case 'router_reset':
            case 'router_encode':
            case 'mvc_use_router':
            case 'mvc_use_module':
                $value = (boolean)$value;
                break;
            case 'domain':
            case 'protocol':
            case 'default_route':
            case 'default_module':
            case 'default_controller':
            case 'default_action':
            case 'mvc_prefix':
                if ((!is_scalar($value)) && ($value !== null)) {
                    trigger_error('Only scalar values are accepted for "' . $name . '" option', E_USER_WARNING);
                    return (false);
                }
                if (!strlen($value)) {
                    $value = null;
                }
                break;
            case 'port':
                $value = max((int)$value, 0);
                if (!$value) {
                    $value = null;
                }
                break;
        }
        return (true);
    }

    /**
     * Generates an URL from given MVC URL target.
     * Function accepts URL target to be defined as array (@see Zend_View_Helper_Url)
     *                                                          or in compact form:
     * (route:)?(module.)?(controller.)?(action)?(/path/to/file.ext)?(?param=value&a=b)?
     *
     * @param string|array $mvc                 MVC URL target
     * @param array $params                     OPTIONAL Additional parameters to set in URL
     * @param array|Zend_Config|null $config    OPTIONAL Configuration options to override default object's configuration
     *                                          Separate $reset and $encode arguments can be passed instead of configuration
     * @see                                                     Zend_Controller_Router_Interface#assemble()
     * @return string
     */
    public static function url($mvc, $params = array(), $config = null)
    {
        // If absolute URL is passed as argument - return it as is
        if ((is_string($mvc)) && (preg_match('/^[a-z0-9\.\+\-]+:\/\//i', $mvc))) {
            return ($mvc);
        }
        $instance = self::getInstance();
        if (is_bool($config)) { // $reset and $encode are passed as separate arguments
            $config = $instance->getConfig();
            $args = func_get_args();
            array_shift($args);
            array_shift($args);
            $config['router_reset'] = array_shift($args);
            $config['router_encode'] = array_shift($args);
        }
        $config = $instance->getConfig($config);
        $config['router_matching'] = false;
        $mvc = self::parse($mvc, $params, $config);
        if ($config['mvc_use_router']) {
            // Build URL using standard ZF routing subsysem
            $params = array_merge($mvc['params'], $mvc['mvc']);
            // Since there is no standard way to pass URL path to routers -
            // use "_rx_url_path" parameter name for it
            if (strlen($mvc['path'])) {
                $params['_rx_url_path'] = $mvc['path'];
            }
            $router = Zend_Controller_Front::getInstance()->getRouter();
            $url = $router->assemble($params, $mvc['route'], $config['router_reset'], $config['router_encode']);
        } else {
            // Build URL using own simple URL builder
            if ($mvc['route'] != $config['default_route']) {
                trigger_error(
                    'Non-default routes are not supported without front controller, URL may be incorrect',
                    E_USER_WARNING
                );
            }
            $url = $instance->assemble($mvc, $config);
        }
        if (($config['complete_url']) && ($config['domain'])) {
            if (substr($url, 0, 1) != '/') {
                $url = '/' . $url;
            }
            $url = sprintf(
                '%s://%s%s%s',
                ($config['protocol']) ? $config['protocol'] : 'http',
                $config['domain'],
                ($config['port']) ? ':' . $config['port'] : '',
                $url
            );
        }
        return ($url);
    }

    /**
     * Assemble given MVC URL target into URL
     *
     * @param array $mvc    MVC URL target to assemble
     * @param array $config Configuration options
     * @return string
     */
    protected function assemble($mvc, $config)
    {
        $url = array();
        // Check if we can skip some MVC path components
        $mvcComponents = array(
            'action'     => urlencode($mvc['mvc']['action']),
            'controller' => urlencode($mvc['mvc']['controller']),
            'module'     => urlencode($mvc['mvc']['module']),
        );
        if ((!$config['mvc_use_module']) ||
            ($mvc['mvc']['module'] === $config['default_module'])
        ) {
            unset($mvcComponents['module']);
        }
        // MVC components can only be skipped if there is
        // no additional path or parameters are defined to avoid problem with URL parsing
        if ((!strlen($mvc['path'])) && (!sizeof($mvc['params']))) {
            foreach ($mvcComponents as $cType => $component) {
                if ($component !== $config['default_' . $cType]) {
                    break;
                }
                unset($mvcComponents[$cType]);
            }
        }
        foreach ($mvcComponents as $component) {
            array_unshift($url, $component);
        }
        // Add base URL
        $baseUrl = trim($config['base_url'], '/');
        if (strlen($baseUrl)) {
            array_unshift($url, $baseUrl);
        }
        // If no additional path is defined - add URL parameters as URL path components
        // as it is normally done by standard ZF module router
        if (!$mvc['path']) {
            foreach ($mvc['params'] as $name => $value) {
                $url[] = urlencode($name);
                $url[] = urlencode($value);
            }
        }
        $url = '/' . join('/', $url);
        if (substr($url, -1) != '/') {
            $url .= '/';
        }
        // If additional path is given - construct URL with this path and URL parameters as query string
        if ($mvc['path']) {
            $url .= ltrim($mvc['path'], '/');
            if (sizeof($mvc['params'])) {
                $url .= (strpos($url, '?') !== false) ? '&' : '?';
                $url .= http_build_query($mvc['params']);
            }
        }
        return ($url);
    }

    /**
     * Get structure that represents parsed MVC URL target
     *
     * @return array
     */
    public function getStruct()
    {
        $config = $this->getConfig();
        $struct = array(
            '__id__' => self::STRUCT_ID,
            'route'  => $config['default_route'], // Route name
            'mvc'    => array( // MVC target, key names are taken from Zend_Controller_Request_Abstract
                'module'     => $config['default_module'],
                'controller' => $config['default_controller'],
                'action'     => $config['default_action'],
            ),
            'path'   => null, // Path from URL target
            'params' => array(), // Additional parameters for URL
        );
        return ($struct);
    }

    /**
     * Parse given MVC URL target into list of parameters for assembling URLs
     *
     * @param string|array $mvc                         MVC URL target
     * @param array|null $params                        OPTIONAL Additional parameters to set in URL
     * @param array|Zend_Config|boolean|null $config    OPTIONAL Configuration options to override default object's configuration
     *                                                  Boolean values are treated as shortcuts for "router_matching" configuration option
     * @return array
     */
    public static function parse($mvc, $params = array(), $config = null)
    {
        $result = self::getInstance()->getStruct();
        if (!is_array($params)) {
            $params = array();
        }
        if (is_array($mvc)) {
            if ((array_key_exists('__id__', $mvc)) && ($mvc['__id__'] == self::STRUCT_ID)) {
                // MVC URL target is given as already parsed structure,
                // no further processing is required in except of merging
                // additional parameters given as argument
                $mvc['params'] = array_merge($mvc['params'], $params);
                return ($mvc);
            } else {
                // Given information is most likely passed in a form used by Zend_View_Helper_Url
                // so parsing should include only fetching MVC and additional parameters from it
                foreach ($result['mvc'] as $name => $value) {
                    if (array_key_exists($name, $mvc)) {
                        $result['mvc'][$name] = $mvc[$name];
                        unset($mvc[$name]);
                    }
                }
                $result['params'] = array_merge($result['params'], $mvc, $params);
                return ($result);
            }
        }
        // Merge given parameters so they will be in place
        // in a case if result will be returned until end of parsing process
        $result['params'] = array_merge($result['params'], $params);
        if (is_bool($config)) {
            $config = array('router_matching' => $config);
        }
        $config = self::getInstance()->getConfig($config);
        $mvcMaskDefaults = $result['mvc'];
        if ($config['mvc_mask']) {
            // Initialize MVC target with mask placeholders instead of current MVC target
            $result['mvc']['module'] = '*';
            $result['mvc']['controller'] = '*';
            $result['mvc']['action'] = '*';
        }
        // Parse given URL target and fill results array
        $mvcTarget = null;
        $path = null;
        if (strpos($mvc, '/') !== false) { // We have MVC target and path components
            $t = explode('/', $mvc, 2);
            $mvcTarget = array_shift($t);
            $path = array_shift($t);
        } elseif (strpos($mvc, '?') !== false) { // We have MVC target and parameters components
            $t = explode('?', $mvc, 2);
            $mvcTarget = array_shift($t);
            $path = '?' . array_shift($t);
        } else { // Just MVC target
            $mvcTarget = $mvc;
        }
        if (!preg_match(
            '/^(?:([a-z0-9\-\_]+)\:)?(?:([a-z0-9\-\_]+)\.)?(?:([a-z0-9\-\_]+)\.)?(?:([a-z0-9\-\_]+))?/i',
            $mvcTarget,
            $match
        )
        ) {
            trigger_error('Failed to parse URL target: ' . $mvc, E_USER_WARNING);
            return ($result);
        }
        // Fix incorrect mapping of matched parts in a case if there is no module is defined
        if ((isset($match[2])) && (isset($match[3])) &&
            (strlen($match[2])) && (!strlen($match[3]))
        ) {
            $match[3] = $match[2];
            $match[2] = null;
        }
        if ((array_key_exists(1, $match)) && (strlen($match[1]))) {
            $result['route'] = $match[1];
        }
        if ((array_key_exists(2, $match)) && (strlen($match[2]))) {
            $result['mvc']['module'] = $match[2];
        }
        if ((array_key_exists(3, $match)) && (strlen($match[3]))) {
            $result['mvc']['controller'] = $match[3];
        }
        if ((array_key_exists(4, $match)) && (strlen($match[4]))) {
            $result['mvc']['action'] = $match[4];
        }
        if ($config['mvc_mask']) {
            foreach ($result['mvc'] as $component => $value) {
                if ($mvcMaskDefaults[$component] == $value) {
                    $result['mvc'][$component] = '*';
                }
            }
            $result = join('.', $result['mvc']);
            return ($result);
        }
        // Parse URL path
        $t = explode('?', $path, 2);
        $result['path'] = array_shift($t);
        $query = array_shift($t);
        parse_str($query, $query);
        $result['params'] = array_merge($result['params'], $query);
        // Finally merge given list of parameters so we will be sure
        // that given parameters will override all parsed parameter values
        if (is_array($params)) {
            $result['params'] = array_merge($result['params'], $params);
        }
        if ($config['router_matching']) {
            // Convert parsing results into list of URL options expected by routers
            // @see Zend_Controller_Router_Route#assemble()
            // MVC parameters have priority since they must appear in results in unchanged way
            // URL path is not added because it is used by routers themselves
            // and not expected to be visible for outer code
            $params = array_merge($result['params'], $result['mvc']);
            return ($params);
        }
        return ($result);
    }

    /**
     * Parse given MVC request object into MVC URL target structure
     *
     * @param Zend_Controller_Request_Abstract|null $request    Request object to parse
     *                                                          null to get current request object from front controller
     * @return array
     */
    public static function parseRequest($request = null)
    {
        $route = null;
        $result = self::getInstance()->getStruct();
        if (!$request instanceof Zend_Controller_Request_Abstract) {
            $request = Zend_Controller_Front::getInstance()->getRequest();
            // If we're using request from front controller -
            // we can also get route name from it
            try {
                /** @var $router Zend_Controller_Router_Rewrite */
                $router = Zend_Controller_Front::getInstance()->getRouter();
                $route = $router->getCurrentRouteName();
            } catch (Zend_Controller_Router_Exception $e) {
                // No current route is available
                $route = null;
            }
        }
        if ($request instanceof Zend_Controller_Request_Abstract) {
            // Avoid putting POST parameters in URL
            $params = $request->getParams();
            /** @var $request Zend_Controller_Request_Http */
            if ($request->isPost()) {
                $post = $request->getPost();
                foreach ($post as $name => $value) {
                    unset($params[$name]);
                }
            }
            $result = self::parse(array(
                'module'     => $request->getModuleName(),
                'controller' => $request->getControllerName(),
                'action'     => $request->getActionName(),
            ), $params);
            // If we know route name - set it too
            if ($route !== null) {
                $result['route'] = $route;
            }
        }
        return ($result);
    }

    /**
     * Convert given MVC URL target into MVC "module.controller.action" form
     *
     * @param string|array $mvc                 MVC URL target in a form supported by parse()
     * @param array|Zend_Config|null $config    OPTIONAL Configuration options to override default object's configuration
     *                                          Boolean values are treated as shortcuts for "mvc_use_module" configuration option
     * @return string
     */
    public static function toMvc($mvc, $config = null)
    {
        if (is_bool($config)) {
            $config = array('mvc_use_module' => $config);
        }
        $config = self::getInstance()->getConfig($config);
        $mvc = self::parse($mvc, null, $config);
        if (!$config['mvc_use_module']) {
            unset($mvc['mvc']['module']);
        }
        $mvc = join('.', $mvc['mvc']);
        $mvc = $config['mvc_prefix'] . $mvc;
        return ($mvc);
    }

}
